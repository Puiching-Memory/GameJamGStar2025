/**
 * å¡ç‰Œæ•ˆæœå¤„ç†å™¨
 * è´Ÿè´£æ‰§è¡Œå¡ç‰Œæ•ˆæœå¹¶å¤„ç†ç›¸å…³é€»è¾‘
 * ä½¿ç”¨æ•ˆæœç»„ä»¶ç³»ç»Ÿ
 */
class CardEffect {
    constructor(gameState, logSystem, cardFactory = null) {
        this.gameState = gameState;
        this.logSystem = logSystem;
        this.cardFactory = cardFactory;
    }

    /**
     * æ ¼å¼åŒ–å¡ç‰Œè¯¦ç»†ä¿¡æ¯
     * @param {Card} card - å¡ç‰Œå®ä¾‹
     * @returns {string} æ ¼å¼åŒ–åçš„å¡ç‰Œä¿¡æ¯å­—ç¬¦ä¸²
     */
    formatCardDetails(card) {
        const parts = [];
        
        // å¡ç‰Œåç§°å’Œå›¾æ ‡
        parts.push(`${card.icon} ${card.name}`);
        
        // è´¹ç”¨
        parts.push(`ğŸ’${card.cost}`);
        
        // æ•°å€¼æ•ˆæœï¼ˆå¦‚æœæœ‰ï¼‰
        const effects = [];
        if (card.power > 0) {
            effects.push(`âš”ï¸${card.power}`);
        }
        if (card.heal > 0) {
            effects.push(`ğŸ’š${card.heal}`);
        }
        if (card.draw > 0) {
            effects.push(`ğŸ“š${card.draw}`);
        }
        if (effects.length > 0) {
            parts.push(effects.join(' '));
        }
        
        // ç±»å‹ï¼ˆå¦‚æœæœ‰ç‰¹æ®Šç±»å‹ï¼‰
        if (card.type && card.type !== 'attack') {
            const typeMap = {
                'heal': 'ğŸ’šæ²»ç–—',
                'special': 'âœ¨ç‰¹æ®Š',
                'buff': 'ğŸ›¡ï¸å¢ç›Š'
            };
            parts.push(typeMap[card.type] || card.type);
        }
        
        return parts.join(' | ');
    }

    /**
     * æ‰§è¡Œå¡ç‰Œæ•ˆæœ
     */
    execute(card, target, cardUser) {
        if (!card.effectComponent) {
            console.warn(`å¡ç‰Œ ${card.name} æ²¡æœ‰æ•ˆæœç»„ä»¶`);
            return null;
        }

        const context = {
            gameState: this.gameState,
            target: target,
            cardUser: cardUser,
            card: card,
            cardFactory: this.cardFactory
        };

        // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‰§è¡Œ
        if (!card.effectComponent.canExecute(context)) {
            return null;
        }

        try {
            // è®°å½•å¡ç‰Œè¯¦ç»†ä¿¡æ¯ï¼ˆåªè®°å½•åˆ°å¼€å‘è€…æ—¥å¿—ï¼Œä¸æ˜¾ç¤ºåœ¨å¼¹å¹•ï¼‰
            if (this.logSystem) {
                const cardDetails = this.formatCardDetails(card);
                this.logSystem.addLog({
                    userMessage: '', // ä¸æ˜¾ç¤ºåœ¨å¼¹å¹•
                    devMessage: `[CardPlay] ${cardUser} æ‰“å‡ºå¡ç‰Œ: ${cardDetails} | Target: ${target} | Mana: ${this.gameState.getCurrentPlayer().mana}/${this.gameState.getCurrentPlayer().maxMana}`
                }, cardUser);
            }

            // æ‰§è¡Œæ•ˆæœ
            const result = card.effectComponent.execute(context);
            
            // è§¦å‘å¡ç‰Œä½¿ç”¨äº‹ä»¶ï¼ˆåªå‘é€å¿…è¦çš„æ•°æ®ï¼Œé¿å…å¾ªç¯å¼•ç”¨ï¼‰
            if (this.gameState.eventSystem) {
                this.gameState.eventSystem.emit('card:played', {
                    card: {
                        id: card.id,
                        name: card.name,
                        icon: card.icon,
                        cost: card.cost,
                        power: card.power || 0,
                        heal: card.heal || 0,
                        draw: card.draw || 0,
                        type: card.type,
                        isAutoGenerated: card.isAutoGenerated || false,
                        isFromBuff: card.isFromBuff || false,
                        isFromAutoBot: card.isFromAutoBot || false
                    },
                    player: cardUser,
                    target: target
                });
            }

            // è®°å½•æ•ˆæœæ—¥å¿—
            if (result && result.message && this.logSystem) {
                const source = result.source || cardUser;
                // å¦‚æœresultä¸­æœ‰userMessageå’ŒdevMessageï¼Œä½¿ç”¨å®ƒä»¬ï¼›å¦åˆ™ä½¿ç”¨message
                if (result.userMessage !== undefined || result.devMessage !== undefined) {
                    this.logSystem.addLog({
                        userMessage: result.userMessage || '',
                        devMessage: result.devMessage || result.message
                    }, source);
                } else {
                    // å‘åå…¼å®¹ï¼šåªæä¾›äº†message
                    this.logSystem.addLog({
                        userMessage: '', // ä¸æ˜¾ç¤ºåœ¨å¼¹å¹•
                        devMessage: `[CardEffect] ${result.message} | Source: ${source} | Card: ${card.name}`
                    }, source);
                }
            }

            return result;
        } catch (error) {
            console.error(`æ‰§è¡Œå¡ç‰Œ ${card.name} çš„æ•ˆæœæ—¶å‘ç”Ÿé”™è¯¯:`, error);
            if (this.logSystem) {
                this.logSystem.addLog({
                    userMessage: `å¡ç‰Œ ${card.name} æ•ˆæœæ‰§è¡Œå¤±è´¥ï¼`,
                    devMessage: `[Error] å¡ç‰Œæ•ˆæœæ‰§è¡Œå¤±è´¥ | Card: ${card.name} | User: ${cardUser} | Target: ${target} | Error: ${error.message || error.toString()}`
                }, 'system');
            }
            return null;
        }
    }

    /**
     * ç¡®å®šå¡ç‰Œç›®æ ‡
     * @param {Card} card - å¡ç‰Œ
     * @param {string} cardUser - å‡ºç‰Œè€… ('player' æˆ– 'opponent')
     */
    determineTarget(card, cardUser) {
        // æ²»ç–—ç‰Œæ€»æ˜¯å¯¹è‡ªå·±ä½¿ç”¨
        if (card.type === 'heal') {
            return cardUser;
        }
        
        // æ”»å‡»ç‰Œï¼šä»æ•Œå¯¹ç©å®¶ä¸­é€‰æ‹©ï¼ˆæ’é™¤è‡ªåŠ¨æœºå™¨äººï¼‰
        const enemyPlayers = this.gameState.getEnemyPlayers();
        if (enemyPlayers.length > 0) {
            // ä¼˜å…ˆé€‰æ‹©ç©å®¶æˆ–å¯¹æ‰‹ï¼ˆéè‡ªåŠ¨æœºå™¨äººï¼‰
            const mainEnemy = enemyPlayers.find(p => p.name === 'player' || p.name === 'opponent');
            if (mainEnemy) {
                return mainEnemy.name;
            }
            // å¦‚æœæ²¡æœ‰ä¸»è¦å¯¹æ‰‹ï¼Œè¿”å›ç¬¬ä¸€ä¸ªæ•Œå¯¹ç©å®¶ï¼ˆè™½ç„¶ç†è®ºä¸Šä¸åº”è¯¥æœ‰è¿™ç§æƒ…å†µï¼‰
            return enemyPlayers[0].name;
        }
        
        // å¦‚æœæ²¡æœ‰æ•Œå¯¹ç©å®¶ï¼Œè¿”å›é»˜è®¤å¯¹æ‰‹ï¼ˆå‘åå…¼å®¹ï¼‰
        return cardUser === 'player' ? 'opponent' : 'player';
    }
}

